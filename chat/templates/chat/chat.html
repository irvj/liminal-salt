{% extends 'base.html' %}
{% load markdown_extras %}

{% block title %}{{ title }} - Liminal Salt{% endblock %}

{% block body_attrs %} style="display: flex; height: 100vh;"{% endblock %}

{% block body %}
<!-- Delete Confirmation Modal (Alpine.js + HTMX) -->
<div x-data="deleteModal()" x-cloak>
    <div x-show="showModal"
         x-transition:enter="transition ease-out duration-200"
         x-transition:leave="transition ease-in duration-150"
         class="fixed inset-0 bg-black/60 flex items-center justify-center z-modal"
         @click.self="showModal = false">
        <div class="bg-surface-secondary rounded-lg p-6 max-w-modal w-[90%] border border-border">
            <h3 class="text-foreground mb-3">Delete Chat?</h3>
            <p class="text-foreground-secondary mb-5">Are you sure you want to delete "<span x-text="sessionTitle"></span>"? This cannot be undone.</p>
            <form hx-post="{% url 'delete_chat' %}"
                  hx-target="#main-content"
                  hx-swap="innerHTML"
                  @htmx:after-request="showModal = false">
                {% csrf_token %}
                <input type="hidden" name="session_id" x-bind:value="sessionId">
                <div class="flex gap-3 justify-end">
                    <button type="button" @click="showModal = false" class="px-4 py-2 bg-surface-elevated text-foreground rounded font-medium cursor-pointer hover:bg-accent hover:text-foreground-on-accent">Cancel</button>
                    <button type="submit" class="px-4 py-2 bg-danger text-foreground-on-accent rounded font-medium cursor-pointer hover:bg-danger-hover">Delete</button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Wipe Memory Confirmation Modal (Alpine.js) -->
<div x-data="wipeMemoryModal()" x-cloak>
    <div x-show="showModal"
         x-transition:enter="transition ease-out duration-200"
         x-transition:leave="transition ease-in duration-150"
         class="fixed inset-0 bg-black/60 flex items-center justify-center z-modal"
         @click.self="showModal = false">
        <div class="bg-surface-secondary rounded-lg p-6 max-w-modal w-[90%] border border-border">
            <h3 class="text-foreground mb-3">Wipe Memory?</h3>
            <p class="text-foreground-secondary mb-5">Are you sure you want to wipe your entire long-term memory? This action cannot be undone.</p>
            <div class="flex gap-3 justify-end">
                <button @click="showModal = false" class="px-4 py-2 bg-surface-elevated text-foreground rounded font-medium cursor-pointer hover:bg-accent hover:text-foreground-on-accent">Cancel</button>
                <button @click="confirmWipe()" class="px-4 py-2 bg-danger text-foreground-on-accent rounded font-medium cursor-pointer hover:bg-danger-hover">Wipe</button>
            </div>
        </div>
    </div>
</div>

<!-- Edit/New Personality Modal (Alpine.js) -->
<div x-data="editPersonalityModal()" x-cloak>
    <div x-show="showModal"
         x-transition:enter="transition ease-out duration-200"
         x-transition:leave="transition ease-in duration-150"
         class="fixed inset-0 bg-black/60 flex items-center justify-center z-modal"
         @click.self="showModal = false">
        <div class="bg-surface-secondary rounded-lg p-6 max-w-modal-xl w-[90%] border border-border">
            <h3 class="text-foreground mb-3" x-text="isNew ? 'New Personality' : 'Edit Personality'"></h3>
            <div class="mb-4">
                <label for="personality-name" class="block mb-2 font-medium text-foreground-secondary">Display Name:</label>
                <input type="text" id="personality-name" x-model="displayName"
                       :disabled="isAssistant"
                       :class="isAssistant ? 'opacity-50 cursor-not-allowed' : ''"
                       class="w-full p-2.5 border border-border rounded bg-surface text-foreground text-sm focus:outline-none focus:border-accent-cyan"
                       @input="displayName = displayName.replace(/[^a-zA-Z0-9 ]/g, '')">
                <p x-show="isAssistant" class="text-foreground-secondary text-xs mt-1">The default personality cannot be renamed.</p>
            </div>
            <label class="block mb-2 font-medium text-foreground-secondary">Personality File:</label>
            <textarea x-model="content" class="w-full h-[400px] bg-surface border border-border rounded text-foreground font-mono text-sm p-3 resize-y mb-4 focus:outline-none focus:border-accent-cyan"></textarea>
            <div class="flex gap-3 justify-end">
                <button @click="showModal = false" class="px-4 py-2 bg-surface-elevated text-foreground rounded font-medium cursor-pointer hover:bg-accent hover:text-foreground-on-accent">Cancel</button>
                <button @click="savePersonality()" class="px-4 py-2 bg-success text-foreground-on-accent rounded font-medium cursor-pointer hover:bg-success/80">Save</button>
            </div>
        </div>
    </div>
</div>

<!-- Delete Personality Modal (Alpine.js) -->
<div x-data="deletePersonalityModal()" x-cloak>
    <div x-show="showModal"
         x-transition:enter="transition ease-out duration-200"
         x-transition:leave="transition ease-in duration-150"
         class="fixed inset-0 bg-black/60 flex items-center justify-center z-modal"
         @click.self="showModal = false">
        <div class="bg-surface-secondary rounded-lg p-6 max-w-modal w-[90%] border border-border">
            <h3 class="text-foreground mb-3">Delete Personality?</h3>
            <p class="text-foreground-secondary mb-5">Are you sure you want to delete "<span x-text="displayName"></span>"? This cannot be undone.</p>
            <div class="flex gap-3 justify-end">
                <button @click="showModal = false" class="px-4 py-2 bg-surface-elevated text-foreground rounded font-medium cursor-pointer hover:bg-accent hover:text-foreground-on-accent">Cancel</button>
                <button @click="confirmDelete()" class="px-4 py-2 bg-danger text-foreground-on-accent rounded font-medium cursor-pointer hover:bg-danger-hover">Delete</button>
            </div>
        </div>
    </div>
</div>

<!-- Context Files Modal (Alpine.js) -->
<div x-data="contextFilesModal()" x-cloak>
    <div x-show="showModal"
         x-transition:enter="transition ease-out duration-200"
         x-transition:leave="transition ease-in duration-150"
         class="fixed inset-0 bg-black/60 flex items-center justify-center z-modal"
         @click.self="showModal = false">
        <div class="bg-surface-secondary rounded-lg p-6 max-w-[500px] w-[90%] border border-border">
            <h2 class="text-foreground mb-2">Context Files</h2>
            <p class="text-foreground-secondary text-sm mb-5">Upload files to provide additional context to the assistant. These are included in every conversation but not used for memory generation.</p>

            <!-- Drop Zone -->
            <div class="border-2 border-dashed border-border rounded-lg p-10 text-center cursor-pointer transition-all mb-5 hover:border-accent hover:bg-accent/10"
                 :class="{ 'border-accent-cyan bg-accent-cyan/15': isDragging }"
                 @dragover.prevent="isDragging = true"
                 @dragleave.prevent="isDragging = false"
                 @drop.prevent="handleDrop($event)"
                 @click="$refs.fileInput.click()">
                <div class="pointer-events-none">
                    <div class="text-5xl mb-3">üìÅ</div>
                    <p class="text-foreground my-2" x-show="!isDragging">Drag & drop files here, or click to browse</p>
                    <p class="text-foreground my-2" x-show="isDragging">Drop files to upload</p>
                    <p class="text-xs text-foreground-secondary">Accepts .md and .txt files</p>
                </div>
                <input type="file"
                       x-ref="fileInput"
                       @change="handleFileSelect($event)"
                       accept=".md,.txt"
                       multiple
                       class="hidden">
            </div>

            <!-- Upload Status -->
            <div x-show="uploadStatus" x-transition class="p-2 px-3 rounded mb-4 text-sm" :class="uploadStatusType === 'success' ? 'bg-success/20 text-success' : 'bg-danger/20 text-danger'">
                <span x-text="uploadStatus"></span>
            </div>

            <!-- File List -->
            <div class="max-h-[200px] overflow-y-auto mb-5">
                <template x-for="file in files" :key="file.name">
                    <div class="flex items-center gap-3 py-2.5 border-b border-surface last:border-b-0">
                        <label class="relative w-11 h-6 shrink-0">
                            <input type="checkbox" :checked="file.enabled" @change="toggleFile(file.name)" class="opacity-0 w-0 h-0 peer">
                            <span class="absolute cursor-pointer inset-0 bg-surface-elevated rounded-full transition-colors peer-checked:bg-accent before:absolute before:content-[''] before:h-[18px] before:w-[18px] before:left-[3px] before:bottom-[3px] before:bg-foreground-secondary before:rounded-full before:transition-transform peer-checked:before:translate-x-5"></span>
                        </label>
                        <span class="flex-1 text-foreground cursor-pointer hover:text-accent-cyan" x-text="file.name" @click="openEditFile(file.name)"></span>
                        <button class="bg-transparent border-none text-danger cursor-pointer text-lg px-2 py-1 hover:text-warning" @click="deleteFile(file.name)">√ó</button>
                    </div>
                </template>
                <p x-show="files.length === 0" class="text-border italic text-center py-5">No context files uploaded.</p>
            </div>

            <!-- Close Button -->
            <div class="flex justify-end gap-3">
                <button @click="showModal = false" class="px-6 py-2.5 bg-accent text-white rounded font-medium hover:bg-accent-hover">Done</button>
            </div>
        </div>
    </div>

    <!-- File Edit Modal (nested) -->
    <div x-show="editModal.show"
         class="fixed inset-0 bg-black/60 flex items-center justify-center z-modal-nested"
         @click.self="editModal.show = false">
        <div class="bg-surface-secondary rounded-lg p-6 max-w-modal-lg w-[90%] border border-border">
            <h2 class="text-foreground mb-2">Edit File</h2>
            <p class="text-accent-cyan font-mono mb-4" x-text="editModal.filename"></p>
            <textarea x-model="editModal.content"
                      class="w-full h-[300px] bg-surface border border-border rounded text-foreground font-mono text-sm p-3 resize-y mb-4 focus:outline-none focus:border-accent-cyan"
                      placeholder="File content..."></textarea>
            <div x-show="editModal.status" class="p-2 px-3 rounded mb-4 text-sm" :class="editModal.statusType === 'success' ? 'bg-success/20 text-success' : 'bg-danger/20 text-danger'">
                <span x-text="editModal.status"></span>
            </div>
            <div class="flex justify-end gap-3">
                <button @click="editModal.show = false" class="px-6 py-2.5 bg-surface-elevated text-foreground rounded font-medium hover:bg-accent hover:text-foreground-on-accent">Cancel</button>
                <button @click="saveEditFile()" class="px-6 py-2.5 bg-accent text-white rounded font-medium hover:bg-accent-hover">Save</button>
            </div>
        </div>
    </div>
</div>

<!-- Sidebar wrapper with mobile state (contents = invisible to flex layout) -->
<div class="contents" x-data="{
        collapsed: localStorage.getItem('sidebarCollapsed') === 'true',
        isMobile: window.innerWidth < 1024,
        init() {
            // Auto-collapse on smaller screens (< 1024px / lg breakpoint)
            if (this.isMobile) this.collapsed = true;

            // Listen for resize
            window.addEventListener('resize', () => {
                const wasMobile = this.isMobile;
                this.isMobile = window.innerWidth < 1024;
                // Auto-collapse when entering mobile
                if (this.isMobile && !wasMobile) this.collapsed = true;
                // Restore localStorage state when returning to desktop
                if (!this.isMobile && wasMobile) {
                    this.collapsed = localStorage.getItem('sidebarCollapsed') === 'true';
                }
            });

            // Persist collapsed state (desktop only)
            this.$watch('collapsed', val => {
                if (!this.isMobile) localStorage.setItem('sidebarCollapsed', val);
            });
        }
     }">

    <!-- Mobile backdrop -->
    <div x-show="isMobile && !collapsed"
         x-transition:enter="transition ease-out duration-200"
         x-transition:enter-start="opacity-0"
         x-transition:enter-end="opacity-100"
         x-transition:leave="transition ease-in duration-150"
         x-transition:leave-start="opacity-100"
         x-transition:leave-end="opacity-0"
         @click="collapsed = true"
         class="fixed inset-0 bg-black/50 z-sidebar-backdrop">
    </div>

    <!-- Sidebar -->
    <aside :class="{
               'w-sidebar-collapsed': collapsed,
               'w-sidebar': !collapsed,
               'fixed inset-y-0 left-0 z-sidebar': isMobile && !collapsed
           }"
           class="h-full bg-surface-secondary p-5 overflow-y-auto border-r border-border transition-all duration-200">

        <!-- Header with toggle -->
        <div class="flex items-center mb-4" :class="collapsed ? 'justify-center' : 'justify-between'">
            <h2 x-show="!collapsed" class="text-accent-cyan text-xl">üßÇ Liminal Salt</h2>
            <button @click="collapsed = !collapsed"
                    class="text-foreground-secondary hover:text-foreground cursor-pointer text-xl"
                    :title="collapsed ? 'Expand sidebar' : 'Collapse sidebar'">
                <span x-show="collapsed">‚ò∞</span>
                <span x-show="!collapsed">¬´</span>
            </button>
        </div>

        <!-- Sidebar content (hidden when collapsed) -->
        <div x-show="!collapsed" x-transition>
            <div id="new-chat-button">
            {% include "chat/new_chat_button.html" %}
            </div>

            <div class="h-px bg-border my-3"></div>

            <!-- Sessions grouped by personality -->
            <div id="sidebar-sessions">
            {% include "chat/sidebar_sessions.html" %}
            </div>

            <div class="h-px bg-border my-3"></div>

            <button hx-get="{% url 'memory' %}"
                    hx-target="#main-content"
                    hx-swap="innerHTML"
                    @click="if (isMobile) collapsed = true; updateSidebarHighlight($el)"
                    class="session-item block w-full p-2.5 my-1 bg-surface-elevated text-foreground rounded text-left text-sm cursor-pointer hover:bg-accent hover:text-foreground-on-accent">
                User Memory
            </button>
            <button hx-get="{% url 'settings' %}"
                    hx-target="#main-content"
                    hx-swap="innerHTML"
                    @click="if (isMobile) collapsed = true; updateSidebarHighlight($el)"
                    class="session-item block w-full p-2.5 my-1 bg-surface-elevated text-foreground rounded text-left text-sm cursor-pointer hover:bg-accent hover:text-foreground-on-accent">
                Settings
            </button>
        </div>
    </aside>
</div>

<!-- Main Chat Area -->
<div class="flex-1 flex flex-col" id="main-content">
    {% if show_home %}
        {% include 'chat/chat_home.html' %}
    {% else %}
        {% include 'chat/chat_main.html' %}
    {% endif %}
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    // Auto-scroll to bottom on page load
    const messagesDiv = document.getElementById('messages');
    if (messagesDiv) {
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // Add user message immediately and show thinking indicator
    function addUserMessage(event) {
        const input = document.getElementById('message-input');
        const message = input.value.trim();

        if (!message) return;

        // Clear input immediately (don't wait for response)
        input.value = '';

        // Create and append user message with container
        const messagesDiv = document.getElementById('messages');
        const now = new Date();

        // Check if we need a date separator for today
        const lastContainer = messagesDiv.querySelector('.message-container:last-of-type');
        let needsSeparator = true;

        if (lastContainer) {
            const lastTimestamp = lastContainer.querySelector('.timestamp[data-utc]');
            if (lastTimestamp) {
                const lastDate = new Date(lastTimestamp.getAttribute('data-utc'));
                if (lastDate.toDateString() === now.toDateString()) {
                    needsSeparator = false;
                }
            }
        } else {
            // No messages yet, check if there's already a separator
            const existingSeparator = messagesDiv.querySelector('.date-separator');
            if (existingSeparator) needsSeparator = false;
        }

        if (needsSeparator) {
            const separator = document.createElement('div');
            separator.className = 'date-separator text-center text-foreground-muted text-xs my-6 relative';
            separator.textContent = formatDateSeparator(now);
            messagesDiv.appendChild(separator);
        }

        const container = document.createElement('div');
        container.className = 'message-container user my-4 max-w-[80%] w-fit ml-auto';

        const userDiv = document.createElement('div');
        userDiv.className = 'message user message-tail-user p-3 px-4 rounded-lg bg-user-bubble text-foreground-on-accent';
        userDiv.textContent = message;
        container.appendChild(userDiv);

        // Add timestamp outside the bubble
        const timestamp = document.createElement('span');
        timestamp.className = 'timestamp block text-xs text-foreground-muted mt-3.5 px-1 text-right';
        timestamp.setAttribute('data-utc', now.toISOString());
        timestamp.textContent = now.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
        container.appendChild(timestamp);

        messagesDiv.appendChild(container);

        // Create and append thinking indicator
        const thinkingDiv = document.createElement('div');
        thinkingDiv.id = 'thinking-indicator';
        thinkingDiv.className = 'message assistant p-3 px-4 rounded-lg bg-assistant-bubble opacity-70 w-fit max-w-[80%] mr-auto my-4';
        thinkingDiv.innerHTML = '<span class="typing-indicator flex gap-1 py-1"><span class="w-2 h-2 bg-foreground-secondary rounded-full animate-bounce-dot"></span><span class="w-2 h-2 bg-foreground-secondary rounded-full animate-bounce-dot" style="animation-delay: 0.2s;"></span><span class="w-2 h-2 bg-foreground-secondary rounded-full animate-bounce-dot" style="animation-delay: 0.4s;"></span></span>';
        messagesDiv.appendChild(thinkingDiv);

        // Scroll to bottom
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // Remove thinking indicator after response arrives
    function removeThinkingIndicator() {
        const thinking = document.getElementById('thinking-indicator');
        if (thinking) {
            thinking.remove();
        }
    }

    // Scroll to bottom helper
    function scrollToBottom() {
        const messagesDiv = document.getElementById('messages');
        if (messagesDiv) {
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
    }

    // Handle textarea keydown: Enter submits, Shift+Enter adds new line
    function handleTextareaKeydown(event) {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            event.target.form.requestSubmit();
        }
    }

    // Auto-resize textarea (called on input, handles typing and paste)
    function autoResizeTextarea(textarea) {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 200) + 'px';
    }

    // Animate assistant response with typewriter effect
    function animateAssistantResponse() {
        const messagesDiv = document.getElementById('messages');
        if (!messagesDiv) return;

        // Get the last assistant message (the newly inserted one)
        const assistantMessages = messagesDiv.querySelectorAll('.message.assistant:not(.thinking)');
        const lastMessage = assistantMessages[assistantMessages.length - 1];
        if (!lastMessage) return;

        // Apply typewriter to the entire message
        typewriterReveal(lastMessage);
    }

    // Typewriter effect - reveal text word by word
    function typewriterReveal(element) {
        // Get all text nodes, but skip code blocks
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, {
            acceptNode: function(node) {
                // Skip text inside PRE or CODE elements
                let parent = node.parentNode;
                while (parent && parent !== element) {
                    if (parent.tagName === 'PRE' || parent.tagName === 'CODE') {
                        return NodeFilter.FILTER_REJECT;
                    }
                    parent = parent.parentNode;
                }
                return node.textContent.trim() ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
            }
        }, false);

        const textNodes = [];
        let node;
        while (node = walker.nextNode()) {
            textNodes.push(node);
        }

        // Wrap each word in a span
        const allWords = [];
        textNodes.forEach(textNode => {
            const words = textNode.textContent.split(/(\s+)/);
            const fragment = document.createDocumentFragment();

            words.forEach(word => {
                if (word.trim()) {
                    const span = document.createElement('span');
                    span.className = 'typewriter-word';
                    span.textContent = word;
                    fragment.appendChild(span);
                    allWords.push(span);
                } else if (word) {
                    fragment.appendChild(document.createTextNode(word));
                }
            });

            textNode.parentNode.replaceChild(fragment, textNode);
        });

        // Reveal words progressively with auto-scroll
        allWords.forEach((wordSpan, index) => {
            setTimeout(() => {
                wordSpan.classList.add('shown');
                // Scroll every 10 words to keep up
                if (index % 10 === 0) {
                    scrollToBottom();
                }
            }, index * 50);
        });

        // Final scroll after all words revealed
        if (allWords.length > 0) {
            setTimeout(() => scrollToBottom(), allWords.length * 50 + 100);
        }
    }

    // Update sidebar highlight when switching sessions
    function updateSidebarHighlight(clickedButton) {
        // Remove 'current' class from all session items
        document.querySelectorAll('.session-item').forEach(item => {
            item.classList.remove('current', 'bg-accent', 'text-foreground-on-accent', 'font-bold');
            item.classList.add('bg-surface-elevated', 'text-foreground');
        });
        // Add 'current' class to clicked button
        clickedButton.classList.add('current', 'bg-accent', 'text-foreground-on-accent', 'font-bold');
        clickedButton.classList.remove('bg-surface-elevated', 'text-foreground');
    }

    // Delete modal state (shared with Alpine)
    let deleteModalState = {
        showModal: false,
        sessionId: '',
        sessionTitle: ''
    };

    // Alpine.js component for delete modal
    function deleteModal() {
        return {
            showModal: false,
            sessionId: '',
            sessionTitle: '',
            init() {
                // Store reference so openDeleteModal can access this
                window.deleteModalComponent = this;
            }
        };
    }

    // Open delete modal (called from delete buttons)
    function openDeleteModal(sessionId, sessionTitle) {
        if (window.deleteModalComponent) {
            window.deleteModalComponent.sessionId = sessionId;
            window.deleteModalComponent.sessionTitle = sessionTitle;
            window.deleteModalComponent.showModal = true;
        }
    }

    // Alpine.js component for wipe memory modal
    function wipeMemoryModal() {
        return {
            showModal: false,
            init() {
                window.wipeMemoryModalComponent = this;
            },
            confirmWipe() {
                this.showModal = false;
                const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;

                // Send wipe request via HTMX-style fetch
                fetch('{% url "wipe_memory" %}', {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': csrfToken,
                        'HX-Request': 'true'
                    }
                }).then(response => response.text())
                .then(html => {
                    const mainContent = document.getElementById('main-content');
                    mainContent.innerHTML = html;
                    htmx.process(mainContent);
                });
            }
        };
    }

    // Open wipe memory modal (called from memory page)
    function openWipeMemoryModal() {
        if (window.wipeMemoryModalComponent) {
            window.wipeMemoryModalComponent.showModal = true;
        }
    }

    // Alpine.js component for edit/new personality modal
    function editPersonalityModal() {
        return {
            showModal: false,
            isNew: false,         // true for new personality, false for edit
            isAssistant: false,   // true if editing the "assistant" personality (cannot rename)
            personality: '',      // Original folder name (empty for new)
            displayName: '',      // User-editable display name
            content: '',
            init() {
                window.editPersonalityModalComponent = this;
            },
            savePersonality() {
                const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;

                // Convert display name to folder name format
                const newFolderName = this.displayName
                    .toLowerCase()
                    .replace(/\s+/g, '_')
                    .replace(/[^a-z0-9_]/g, '');

                const url = this.isNew ? '{% url "create_personality" %}' : '{% url "save_personality_file" %}';
                // Don't send new_name for assistant personality (cannot be renamed)
                const body = this.isNew
                    ? `name=${encodeURIComponent(newFolderName)}&content=${encodeURIComponent(this.content)}`
                    : this.isAssistant
                        ? `personality=${encodeURIComponent(this.personality)}&content=${encodeURIComponent(this.content)}`
                        : `personality=${encodeURIComponent(this.personality)}&new_name=${encodeURIComponent(newFolderName)}&content=${encodeURIComponent(this.content)}`;

                fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-CSRFToken': csrfToken,
                        'HX-Request': 'true'
                    },
                    body: body
                })
                .then(response => response.text())
                .then(html => {
                    const mainContent = document.getElementById('main-content');
                    mainContent.innerHTML = html;
                    htmx.process(mainContent);  // Re-initialize HTMX on new content
                    this.showModal = false;
                });
            }
        };
    }

    // Open edit personality modal (called from settings page)
    function openEditPersonalityModal() {
        if (window.editPersonalityModalComponent) {
            const select = document.getElementById('personality');
            const personality = select ? select.value : '';
            const content = window.personalityRawContent || '';

            // Convert folder name to display name for editing
            const displayName = personality.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());

            window.editPersonalityModalComponent.isNew = false;
            window.editPersonalityModalComponent.isAssistant = (personality === 'assistant');
            window.editPersonalityModalComponent.personality = personality;
            window.editPersonalityModalComponent.displayName = displayName;
            window.editPersonalityModalComponent.content = content;
            window.editPersonalityModalComponent.showModal = true;
        }
    }

    // Open new personality modal (called from settings page)
    function openNewPersonalityModal() {
        if (window.editPersonalityModalComponent) {
            window.editPersonalityModalComponent.isNew = true;
            window.editPersonalityModalComponent.isAssistant = false;
            window.editPersonalityModalComponent.personality = '';
            window.editPersonalityModalComponent.displayName = '';
            window.editPersonalityModalComponent.content = '';
            window.editPersonalityModalComponent.showModal = true;
        }
    }

    // Alpine.js component for delete personality modal
    function deletePersonalityModal() {
        return {
            showModal: false,
            personality: '',
            displayName: '',
            init() {
                window.deletePersonalityModalComponent = this;
            },
            confirmDelete() {
                const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;

                fetch('{% url "delete_personality" %}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-CSRFToken': csrfToken,
                        'HX-Request': 'true'
                    },
                    body: `personality=${encodeURIComponent(this.personality)}`
                })
                .then(response => response.text())
                .then(html => {
                    const mainContent = document.getElementById('main-content');
                    mainContent.innerHTML = html;
                    htmx.process(mainContent);
                    this.showModal = false;
                });
            }
        };
    }

    // Open delete personality modal (called from settings page)
    function openDeletePersonalityModal() {
        if (window.deletePersonalityModalComponent) {
            const select = document.getElementById('personality');
            const personality = select ? select.value : '';
            const displayName = personality.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());

            window.deletePersonalityModalComponent.personality = personality;
            window.deletePersonalityModalComponent.displayName = displayName;
            window.deletePersonalityModalComponent.showModal = true;
        }
    }

    // Context Files Modal
    function contextFilesModal() {
        return {
            showModal: false,
            isDragging: false,
            files: [],
            uploadStatus: '',
            uploadStatusType: '',
            editModal: {
                show: false,
                filename: '',
                content: '',
                status: '',
                statusType: ''
            },

            init() {
                window.contextFilesModalComponent = this;
                this.loadFiles();
            },

            loadFiles() {
                this.files = window.contextFilesData || [];
            },

            handleDrop(event) {
                this.isDragging = false;
                const files = event.dataTransfer.files;
                this.uploadFiles(files);
            },

            handleFileSelect(event) {
                const files = event.target.files;
                this.uploadFiles(files);
                event.target.value = '';
            },

            async uploadFiles(fileList) {
                for (const file of fileList) {
                    if (!file.name.endsWith('.md') && !file.name.endsWith('.txt')) {
                        this.showStatus(`${file.name}: Invalid file type`, 'error');
                        continue;
                    }

                    const formData = new FormData();
                    formData.append('file', file);
                    formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);

                    try {
                        const response = await fetch('/memory/context/upload/', {
                            method: 'POST',
                            body: formData,
                            headers: {
                                'X-Requested-With': 'XMLHttpRequest'
                            }
                        });

                        if (response.ok) {
                            const data = await response.json();
                            this.files = data.files;
                            window.contextFilesData = data.files;
                            this.showStatus(`Uploaded ${file.name}`, 'success');
                            this.updateBadge();
                        } else {
                            this.showStatus(`Failed to upload ${file.name}`, 'error');
                        }
                    } catch (err) {
                        this.showStatus(`Error uploading ${file.name}`, 'error');
                    }
                }
            },

            async toggleFile(filename) {
                const formData = new FormData();
                formData.append('filename', filename);
                formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);

                const response = await fetch('/memory/context/toggle/', {
                    method: 'POST',
                    body: formData,
                    headers: { 'X-Requested-With': 'XMLHttpRequest' }
                });

                if (response.ok) {
                    const data = await response.json();
                    this.files = data.files;
                    window.contextFilesData = data.files;
                }
            },

            async deleteFile(filename) {
                if (!confirm(`Delete ${filename}?`)) return;

                const formData = new FormData();
                formData.append('filename', filename);
                formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);

                const response = await fetch('/memory/context/delete/', {
                    method: 'POST',
                    body: formData,
                    headers: { 'X-Requested-With': 'XMLHttpRequest' }
                });

                if (response.ok) {
                    const data = await response.json();
                    this.files = data.files;
                    window.contextFilesData = data.files;
                    this.showStatus(`Deleted ${filename}`, 'success');
                    this.updateBadge();
                }
            },

            showStatus(message, type) {
                this.uploadStatus = message;
                this.uploadStatusType = type;
                setTimeout(() => {
                    this.uploadStatus = '';
                }, 3000);
            },

            updateBadge() {
                const badge = document.querySelector('.context-files-btn .badge');
                if (badge) {
                    badge.textContent = this.files.length;
                    badge.style.display = this.files.length > 0 ? 'inline' : 'none';
                }
            },

            async openEditFile(filename) {
                this.editModal.filename = filename;
                this.editModal.status = '';

                const response = await fetch(`/memory/context/content/?filename=${encodeURIComponent(filename)}`, {
                    headers: { 'X-Requested-With': 'XMLHttpRequest' }
                });

                if (response.ok) {
                    const data = await response.json();
                    this.editModal.content = data.content;
                    this.editModal.show = true;
                } else {
                    this.showStatus(`Failed to load ${filename}`, 'error');
                }
            },

            async saveEditFile() {
                const formData = new FormData();
                formData.append('filename', this.editModal.filename);
                formData.append('content', this.editModal.content);
                formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);

                const response = await fetch('/memory/context/save/', {
                    method: 'POST',
                    body: formData,
                    headers: { 'X-Requested-With': 'XMLHttpRequest' }
                });

                if (response.ok) {
                    this.editModal.status = 'Saved successfully';
                    this.editModal.statusType = 'success';
                    setTimeout(() => {
                        this.editModal.show = false;
                    }, 1000);
                } else {
                    this.editModal.status = 'Failed to save';
                    this.editModal.statusType = 'error';
                }
            }
        };
    }

    function openContextFilesModal() {
        if (window.contextFilesModalComponent) {
            window.contextFilesModalComponent.loadFiles();
            window.contextFilesModalComponent.showModal = true;
        }
    }

    // Alpine.js component for Provider & Model settings (used in settings_main.html partial)
    function providerModelSettings() {
        return {
            // Properties with defaults (populated in init from data-* attributes)
            currentProvider: '',
            currentModel: '',
            hasExistingKey: false,
            providers: [],
            providerOpen: false,
            selectedProvider: '',
            selectedProviderName: '',
            apiKey: '',
            apiKeyModified: false,
            apiKeyValid: false,
            apiKeyError: '',
            validating: false,
            models: [],
            modelOpen: false,
            modelSearch: '',
            selectedModel: '',
            modelHighlightedIndex: 0,
            statusMessage: '',
            statusType: '',
            saving: false,

            // URLs (populated from data attributes)
            validateUrl: '',
            saveUrl: '',
            csrfToken: '',

            init() {
                const el = this.$el;
                this.currentProvider = el.dataset.provider || '';
                this.currentModel = el.dataset.model || '';
                this.hasExistingKey = el.dataset.hasExistingKey === 'true';
                this.selectedProvider = el.dataset.provider || 'openrouter';
                this.selectedProviderName = el.dataset.providerName || '';
                this.modelSearch = el.dataset.model || '';
                this.selectedModel = el.dataset.model || '';
                this.apiKeyValid = el.dataset.hasExistingKey === 'true';
                this.validateUrl = el.dataset.validateUrl || '';
                this.saveUrl = el.dataset.saveUrl || '';
                this.csrfToken = el.dataset.csrfToken || '';

                // Parse providers from JSON
                try {
                    this.providers = JSON.parse(el.dataset.providers || '[]');
                } catch (e) {
                    this.providers = [];
                }

                // Load models if we have an existing key
                if (this.hasExistingKey) {
                    this.loadExistingModels();
                }
            },

            get currentProviderData() {
                return this.providers.find(p => p.id === this.selectedProvider);
            },

            get showModelPicker() {
                return this.apiKeyValid || this.hasExistingKey;
            },

            get filteredModels() {
                if (!this.modelSearch) return this.models.slice(0, 50);
                const s = this.modelSearch.toLowerCase();
                return this.models.filter(m =>
                    m.display.toLowerCase().includes(s) || m.id.toLowerCase().includes(s)
                ).slice(0, 50);
            },

            get canSave() {
                const hasValidKey = this.apiKeyValid || (this.hasExistingKey && !this.apiKeyModified);
                return hasValidKey && this.selectedModel;
            },

            selectProvider(provider) {
                this.selectedProvider = provider.id;
                this.selectedProviderName = provider.name;
                this.providerOpen = false;
                if (provider.id !== this.currentProvider) {
                    this.apiKey = '';
                    this.apiKeyModified = true;
                    this.apiKeyValid = false;
                    this.models = [];
                    this.selectedModel = '';
                    this.modelSearch = '';
                }
            },

            onApiKeyChange() {
                this.apiKeyModified = true;
                this.apiKeyValid = false;
                this.apiKeyError = '';
            },

            async loadExistingModels() {
                try {
                    const formData = new FormData();
                    formData.append('provider', this.selectedProvider);
                    formData.append('use_existing', 'true');

                    const response = await fetch(this.validateUrl, {
                        method: 'POST',
                        headers: { 'X-CSRFToken': this.csrfToken },
                        body: formData
                    });
                    const data = await response.json();
                    if (data.valid && data.models) {
                        this.models = data.models;
                        // Update modelSearch to show display name of current model
                        const currentModel = this.models.find(m => m.id === this.selectedModel);
                        if (currentModel) {
                            this.modelSearch = currentModel.display;
                        }
                    }
                } catch (e) {
                    console.error('Failed to load models:', e);
                    this.statusMessage = 'Failed to load models. Please try again.';
                    this.statusType = 'error';
                }
            },

            async validateApiKey() {
                this.validating = true;
                this.apiKeyError = '';

                try {
                    const formData = new FormData();
                    formData.append('provider', this.selectedProvider);
                    formData.append('api_key', this.apiKey);

                    const response = await fetch(this.validateUrl, {
                        method: 'POST',
                        headers: { 'X-CSRFToken': this.csrfToken },
                        body: formData
                    });
                    const data = await response.json();

                    if (data.valid) {
                        this.apiKeyValid = true;
                        this.models = data.models || [];
                        this.selectedModel = '';
                        this.modelSearch = '';
                    } else {
                        this.apiKeyError = data.error || 'Invalid API key';
                    }
                } catch (e) {
                    this.apiKeyError = 'Validation failed. Please try again.';
                } finally {
                    this.validating = false;
                }
            },

            selectModel(model) {
                this.selectedModel = model.id;
                this.modelSearch = model.display;
                this.modelOpen = false;
            },

            selectHighlightedModel() {
                if (this.filteredModels.length > 0) {
                    this.selectModel(this.filteredModels[this.modelHighlightedIndex]);
                }
            },

            highlightNextModel() {
                if (this.modelHighlightedIndex < this.filteredModels.length - 1) {
                    this.modelHighlightedIndex++;
                    this.scrollToHighlightedModel();
                }
            },

            highlightPrevModel() {
                if (this.modelHighlightedIndex > 0) {
                    this.modelHighlightedIndex--;
                    this.scrollToHighlightedModel();
                }
            },

            scrollToHighlightedModel() {
                this.$nextTick(() => {
                    const dropdown = this.$root.querySelector('.max-h-64');
                    const buttons = dropdown?.querySelectorAll('button');
                    const highlighted = buttons?.[this.modelHighlightedIndex];
                    if (dropdown && highlighted) {
                        const itemTop = highlighted.offsetTop;
                        const itemBottom = itemTop + highlighted.offsetHeight;
                        const viewTop = dropdown.scrollTop;
                        const viewBottom = viewTop + dropdown.clientHeight;

                        if (itemBottom > viewBottom) {
                            dropdown.scrollTop = itemBottom - dropdown.clientHeight;
                        } else if (itemTop < viewTop) {
                            dropdown.scrollTop = itemTop;
                        }
                    }
                });
            },

            async saveProviderModel() {
                this.saving = true;
                this.statusMessage = '';

                try {
                    const formData = new FormData();
                    formData.append('provider', this.selectedProvider);
                    formData.append('model', this.selectedModel);

                    if (this.apiKeyModified && this.apiKey) {
                        formData.append('api_key', this.apiKey);
                    } else {
                        formData.append('keep_existing_key', 'true');
                    }

                    const response = await fetch(this.saveUrl, {
                        method: 'POST',
                        headers: { 'X-CSRFToken': this.csrfToken },
                        body: formData
                    });
                    const data = await response.json();

                    if (data.success) {
                        this.statusMessage = 'Provider and model updated successfully!';
                        this.statusType = 'success';
                        this.currentProvider = data.provider;
                        this.currentModel = data.model;
                        this.hasExistingKey = true;
                        this.apiKeyModified = false;
                        setTimeout(() => { this.statusMessage = ''; }, 3000);
                    } else {
                        this.statusMessage = data.error || 'Failed to save settings';
                        this.statusType = 'error';
                    }
                } catch (e) {
                    this.statusMessage = 'Failed to save settings. Please try again.';
                    this.statusType = 'error';
                } finally {
                    this.saving = false;
                }
            }
        };
    }

    // Show memory updating indicator (called via HTMX hx-on::before-request)
    function showMemoryUpdating() {
        const status = document.getElementById('memory-status');
        const btn = document.getElementById('update-memory-btn');
        if (status) {
            status.style.display = 'inline';
            status.innerHTML = ' ¬∑ Updating Memory<span class="updating-dots"><span>.</span><span>.</span><span>.</span></span>';
        }
        if (btn) btn.disabled = true;
    }

    // Show memory modifying indicator and clear input (called via HTMX hx-on::before-request)
    function showMemoryModifying(event) {
        // Clear input immediately
        const input = document.getElementById('memory-command-input');
        if (input) input.value = '';

        // Show updating status
        const status = document.getElementById('memory-status');
        if (status) {
            status.style.display = 'inline';
            status.innerHTML = ' ¬∑ Updating Memory<span class="updating-dots"><span>.</span><span>.</span><span>.</span></span>';
        }
    }

    // Listen for HTMX responses to update title when it changes
    document.body.addEventListener('htmx:afterRequest', function(event) {
        // Re-set timezone input after HTMX swaps (input may have been replaced)
        setTimezoneInput();

        const xhr = event.detail.xhr;
        if (!xhr) return;

        const newTitle = xhr.getResponseHeader('X-Chat-Title');
        const sessionId = xhr.getResponseHeader('X-Chat-Session-Id');

        if (newTitle && sessionId) {
            // Update sidebar item
            const sidebarItem = document.querySelector(`.session-row[data-session-id="${sessionId}"] .session-item`);
            if (sidebarItem) {
                sidebarItem.textContent = newTitle;
            }

            // Update header title
            const headerTitle = document.querySelector('.header h1');
            if (headerTitle) {
                headerTitle.textContent = newTitle;
            }
        }

        // Convert timestamps and add date separators after HTMX swap
        convertTimestamps();
        insertDateSeparators();
    });

    // Set timezone hidden input value
    function setTimezoneInput() {
        const input = document.getElementById('timezone-input');
        if (input) {
            input.value = Intl.DateTimeFormat().resolvedOptions().timeZone;
        }
    }

    // Convert UTC timestamps to local time (always show time)
    function convertTimestamps() {
        const timestamps = document.querySelectorAll('.timestamp[data-utc]');

        timestamps.forEach(el => {
            const utc = el.getAttribute('data-utc');
            if (!utc || el.textContent) return; // Skip if already converted

            try {
                const date = new Date(utc);
                if (isNaN(date.getTime())) return;

                // Always show time
                el.textContent = date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
            } catch (e) {
                // Silently fail for invalid timestamps
            }
        });
    }

    // Format date for separator (Today, Yesterday, or full date)
    function formatDateSeparator(date) {
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);
        const messageDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

        if (messageDate.getTime() === today.getTime()) {
            return 'Today';
        } else if (messageDate.getTime() === yesterday.getTime()) {
            return 'Yesterday';
        } else {
            return date.toLocaleDateString([], { month: 'long', day: 'numeric', year: 'numeric' });
        }
    }

    // Insert date separators above first message of each date
    function insertDateSeparators() {
        const messagesDiv = document.getElementById('messages');
        if (!messagesDiv) return;

        const containers = messagesDiv.querySelectorAll('.message-container');
        let lastDateStr = null;

        containers.forEach(container => {
            const timestamp = container.querySelector('.timestamp[data-utc]');
            if (!timestamp) return;

            const utc = timestamp.getAttribute('data-utc');
            if (!utc) return;

            try {
                const date = new Date(utc);
                if (isNaN(date.getTime())) return;

                const dateStr = date.toDateString();

                if (dateStr !== lastDateStr) {
                    // Check if separator already exists
                    const prevSibling = container.previousElementSibling;
                    if (prevSibling && prevSibling.classList.contains('date-separator')) {
                        lastDateStr = dateStr;
                        return;
                    }

                    // Insert new date separator
                    const separator = document.createElement('div');
                    separator.className = 'date-separator text-center text-foreground-muted text-xs my-6 relative';
                    separator.textContent = formatDateSeparator(date);
                    container.parentNode.insertBefore(separator, container);

                    lastDateStr = dateStr;
                }
            } catch (e) {
                // Silently fail
            }
        });
    }

    // Theme toggle function
    function setTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
        setTimezoneInput();
        convertTimestamps();
        insertDateSeparators();
    });
</script>
{% endblock %}
